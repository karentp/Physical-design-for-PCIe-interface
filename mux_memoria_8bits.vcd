$date
	Thu May 27 17:47:13 2021
$end
$version
	Icarus Verilog
$end
$timescale
	100ps
$end
$scope module BUF $end
$var wire 1 ! A $end
$var wire 1 " Y $end
$upscope $end
$scope module BancoPruebas $end
$var wire 1 # outValid $end
$var wire 1 $ valid1 $end
$var wire 1 % valid0 $end
$var wire 8 & data_outE [7:0] $end
$var wire 8 ' data_outC [7:0] $end
$var wire 1 ( clk2 $end
$var wire 1 ) clk $end
$var wire 8 * In1 [7:0] $end
$var wire 8 + In0 [7:0] $end
$scope module mux2x1cond $end
$var wire 1 $ valid1 $end
$var wire 1 % valid0 $end
$var wire 1 ) clk $end
$var wire 8 , In1 [7:0] $end
$var wire 8 - In0 [7:0] $end
$var reg 8 . ValorAnterior [7:0] $end
$var reg 8 / data_out [7:0] $end
$var reg 1 0 outValid $end
$var reg 1 1 selector $end
$var reg 1 2 validTemp $end
$upscope $end
$scope module mux2x1estruct $end
$var wire 1 3 _04_ $end
$var wire 1 4 _05_ $end
$var wire 1 5 _06_ $end
$var wire 1 6 validTemp $end
$var wire 1 $ valid1 $end
$var wire 1 % valid0 $end
$var wire 1 ) clk $end
$var wire 32 7 _03_ [31:0] $end
$var wire 1 8 _02_ $end
$var wire 8 9 _01_ [7:0] $end
$var wire 1 : _00_ $end
$var wire 8 ; ValorAnterior [7:0] $end
$var wire 8 < In1 [7:0] $end
$var wire 8 = In0 [7:0] $end
$var reg 8 > data_out [7:0] $end
$var reg 1 ? outValid $end
$var reg 1 @ selector $end
$upscope $end
$scope module prob $end
$var wire 8 A data_out [7:0] $end
$var wire 1 # outValid $end
$var reg 8 B In0 [7:0] $end
$var reg 8 C In1 [7:0] $end
$var reg 1 D Reset_L $end
$var reg 1 ) clk $end
$var reg 1 ( clk2 $end
$var reg 1 E dummy1 $end
$var reg 1 % valid0 $end
$var reg 1 $ valid1 $end
$upscope $end
$upscope $end
$scope module DFF $end
$var wire 1 F C $end
$var wire 1 G D $end
$var reg 1 H Q $end
$upscope $end
$scope module DFFSR $end
$var wire 1 I C $end
$var wire 1 J D $end
$var wire 1 K R $end
$var wire 1 L S $end
$var reg 1 M Q $end
$upscope $end
$scope module NAND $end
$var wire 1 N A $end
$var wire 1 O B $end
$var wire 1 P Y $end
$upscope $end
$scope module NOR $end
$var wire 1 Q A $end
$var wire 1 R B $end
$var wire 1 S Y $end
$upscope $end
$scope module NOT $end
$var wire 1 T A $end
$var wire 1 U Y $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
zU
zT
xS
zR
zQ
xP
zO
zN
xM
zL
zK
zJ
zI
xH
zG
zF
0E
xD
bx C
bx B
bz A
0@
x?
bx >
bx =
bx <
bx ;
1:
b0 9
08
b1 7
x6
15
04
x3
02
01
x0
bx /
b0 .
bx -
bx ,
bx +
bx *
0)
1(
bx '
bx &
x%
x$
x#
z"
z!
$end
#200
0(
#400
18
b11 9
b11 .
0:
b10 7
05
14
00
b0 '
b0 /
11
1@
16
03
b11 ;
12
1D
1$
1%
b11 *
b11 ,
b11 <
b11 C
b0 +
b0 -
b0 =
b0 B
1(
1)
#600
0(
#800
1(
0)
#1000
0(
#1200
13
08
b1 ;
1:
b1 7
15
04
b0 9
b1 .
12
0@
1#
1?
b11 &
b11 >
b100 *
b100 ,
b100 <
b100 C
b1 +
b1 -
b1 =
b1 B
10
b11 '
b11 /
01
1(
1)
#1400
0(
#1600
1(
0)
#1800
0(
#2000
03
18
b101 9
b101 ;
b101 .
12
0:
b10 7
05
14
b1 '
b1 /
11
b101 *
b101 ,
b101 <
b101 C
b10 +
b10 -
b10 =
b10 B
b1 &
b1 >
1@
1(
1)
#2200
0(
#2400
1(
0)
#2600
0(
#2800
13
08
b11 ;
1:
b1 7
15
04
b0 9
b11 .
12
0@
b101 &
b101 >
b110 *
b110 ,
b110 <
b110 C
b11 +
b11 -
b11 =
b11 B
b101 '
b101 /
01
1(
1)
#3000
0(
#3200
1(
0)
#3400
0(
#3600
03
18
b111 9
b111 ;
b111 .
12
0:
b10 7
05
14
b11 '
b11 /
11
b111 *
b111 ,
b111 <
b111 C
b100 +
b100 -
b100 =
b100 B
b11 &
b11 >
1@
1(
1)
#3800
0(
#4000
1(
0)
#4200
0(
#4400
13
08
b101 ;
1:
b1 7
15
04
b0 9
b101 .
12
0@
b111 &
b111 >
b1000 *
b1000 ,
b1000 <
b1000 C
b101 +
b101 -
b101 =
b101 B
b111 '
b111 /
01
1(
1)
#4600
0(
#4800
1(
0)
#5000
0(
#5200
03
18
b1001 9
b1001 ;
b1001 .
12
0:
b10 7
05
14
b101 '
b101 /
11
b1001 *
b1001 ,
b1001 <
b1001 C
b110 +
b110 -
b110 =
b110 B
b101 &
b101 >
1@
1(
1)
#5400
0(
#5600
1(
0)
#5800
0(
#6000
13
08
b111 ;
1:
b1 7
15
04
b0 9
b111 .
12
0@
b1001 &
b1001 >
b1010 *
b1010 ,
b1010 <
b1010 C
b111 +
b111 -
b111 =
b111 B
b1001 '
b1001 /
01
1(
1)
#6200
0(
#6400
1(
0)
#6600
0(
#6800
03
18
b1011 9
b1011 ;
b1011 .
12
0:
b10 7
05
14
b111 '
b111 /
11
b1011 *
b1011 ,
b1011 <
b1011 C
b1000 +
b1000 -
b1000 =
b1000 B
b111 &
b111 >
1@
1(
1)
#7000
0(
#7200
1(
0)
#7400
0(
#7600
13
08
1:
b1 7
15
04
0@
b1011 &
b1011 >
b1011 '
b1011 /
01
b0 ;
b0 9
b0 .
12
b0 *
b0 ,
b0 <
b0 C
b0 +
b0 -
b0 =
b0 B
1(
1)
